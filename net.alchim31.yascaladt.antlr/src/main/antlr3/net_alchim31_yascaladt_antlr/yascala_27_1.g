grammar yascala_27_1;
// based on
// - the grammar python_v3.g from dltk.python
// - EBNF of scala specification 2.7.x

options
{
//	k = 2;

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractYaScalaParser;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    //tokenVocab = TLexer;
}

@lexer::header {
  package net_alchim31_yascala_antlr;
}
@lexer::members {
  /** Handles context-sensitive lexing of implicit line joining such as
   *  the case where newline is ignored in cases like this:
   *  a = [3,
   *       4]
   */
  public int implicitLineJoiningLevel = 0;
  public int startPos=-1;
  public voID emitErrorMessage(String msg) {
  }
}


@parser::header {
  package net_alchim31_yascala_antlr;
}
@parser::members {
public DLTKErrorReporter reporter;

public ModuleDeclaration decl;

public int length;
public DLTKTokenConverter converter;
DLTKToken toDLTK(Token token) {
  return converter.convert(token);
}
public void emitErrorMessage(String msg) {
  reporter.reportMessage(msg);
}
public void reportError(RecognitionException e) {
  if( reporter != null ) {
    reporter.reportError(e);
  }
}
public void setStartEndForEmbracedExpr(Expression exp, Token lb, Token rb)
{
  exp.setStart(toDLTK(lb).getColumn());
  exp.setEnd(toDLTK(rb).getColumn()+1);
}
}

@rulecatch {
catch (RecognitionException re) {
  if( reporter != null ) {
    reporter.reportError(re);
  }
  recover(input,re);
}
catch (Throwable extre) {
  //System.err.println(t);
  if( reporter != null ) {
    reporter.reportThrowable(extre);
  }
}
}
literal :
    INT_LITERAL
  | FLOAT_LITERAL
  | DOUBLE_LITERAL
  | BOOLEAN_LITERAL
  | CHAR_LITERAL
  | STRING_LITERAL
  | SYMBOL_LITERAL
  | 'null'
  ;
eoi	:  (NEWLINE  |	SEMI)+
  ;
qualId : ID ('.' ID)*
  ;
ids : ID (',' ID)*
  ;
stableId : stableIdFrag ('.' stableIdFrag)* ;

stableIdFrag 
	:	'this'
	|	'super' classQualifier
	|	ID
	;
	
classQualifier :
    LBRACK ID RBRACK
  ;
type :
    infixType ('=>' type |  existentialClause)?
  | LPAREN ('=>' type)? RPAREN '=>' type
  ;
existentialClause :
    'forSome' LCURLY existentialDcl (eoi existentialDcl)* RCURLY
  ;
existentialDcl :
    'type' typeDcl
  | 'val' valDcl
  ;
infixType : compoundType (ID NEWLINE? compoundType)*
  ;
compoundType      :
    annotType ('with' annotType)* refinement?
  | refinement
  ;
annotType   : simpleType annotation*
  ;
simpleType  :
    (stableId | stableId '.' 'type') (typeArgs | '#' ID)*
  ;
typeArgs :
    LBRACK types RBRACK
  ;
types :
    type (',' type)*
  ;
refinement  :
    NEWLINE? LCURLY refineStat (eoi refineStat)* RCURLY
  ;
refineStat  :
    dcl
  | 'type' typeDef
  ;
typePat     : type
  ;
ascription  :
    ':' infixType
  | ':' annotation+
  | ':' '_' '*'
  ;
expr :
    (bindings | ID | '_') '=>' expr
  | expr1
  ;
expr1 :
    'if' LPAREN expr RPAREN NEWLINE? expr (eoi? 'else' expr)?
  | 'while' LPAREN expr RPAREN NEWLINE? expr
  | 'try' LCURLY block RCURLY ('catch' LCURLY caseClauses RCURLY)* ('finally' expr)? // TODO adjust the rul (at least one catch or finally
  | 'do' expr eoi? 'while' LPAREN expr RPAREN
  | 'for' (LPAREN enumerators RPAREN | LCURLY enumerators RCURLY)+ NEWLINE? 'yield'? expr
  | 'throw' expr
  | 'return' expr?
  | (simpleExpr '.')? ID '=' expr
  | postfixExpr
  | postfixExpr ascription
  | postfixExpr 'match' LCURLY caseClauses RCURLY
  ;
postfixExpr :
    infixExpr (ID NEWLINE)?
  ;
infixExpr   :
    (prefixExpr) (ID NEWLINE? infixExpr)*
  ;
prefixExpr  :
    ('-' | '+' | '~' | '!')? simpleExpr
  ;
simpleExpr  :
    simpleExpr0 (('.' ID)  | typeArgs | argumentExprs | '_')*
  ;
simpleExpr0  :
    'new' (classTemplate | templateBody)
  | blockExpr
  | literal | stableId | '_'
  ;
  //xmlExpo
exprs :
    expr (',' expr)*
  ;
argumentExprs     :
    LPAREN exprs? RPAREN
  | NEWLINE? blockExpr
  ;
blockExpr         :
    LCURLY caseClauses RCURLY
  | LCURLY block RCURLY
  ;
block             :
    (blockStat eoi)* resultExpr?
  ;
blockStat         :
    import0
  | ('implicit' | 'lazy')? def
  | localModifier* tmplDef
  | expr1
  ;
resultExpr        :
    expr1
  | (bindings | (ID | '_') ':' compoundType) '=>' block
  ;
enumerators       : generator (eoi enumerator)*
  ;
enumerator        : generator
  | guard
  | 'val' pattern1 '=' expr
  ;
generator         : pattern1 '<-' expr guard?
  ;
caseClauses       : caseClause caseClause*
  ;
caseClause        : 'case' pattern [guard] '=>' block
  ;
guard             : 'if' postfixExpr
  ;
pattern           : pattern1 ( '|' pattern1 )*
  ;
pattern1          :
    VARID ':' typePat
  | '_' ':' typePat
  | pattern2
  ;
pattern2          :
    VARID ('@' pattern3)?
  | pattern3
  ;
pattern3          :
    simplePattern
  | simplePattern ( ID NEWLINE? simplePattern )*
  ;
simplePattern     : '_'
  | VARID
  | literal
  | stableId
  | stableId LPAREN (patterns ','?)? RPAREN
  | stableId LPAREN (patterns ',')? (VARID '@')? '_' '*' RPAREN
  | LPAREN (patterns ','?) RPAREN
//  | xmlPattern
  ;
patterns          :
    pattern (',' patterns)?
  | '_' *
  ;
typeParamClause   :
    LBRACK variantTypeParam (',' variantTypeParam)* RBRACK
  ;
funTypeParamClause :
    LBRACK typeParam (',' typeParam)* RBRACK
  ;
variantTypeParam :  ('+' | '-')? typeParam
  ;
typeParam         : (ID | '_') typeParamClause? ('>:' type)? ('<:' type)? ('<%' type)?
  ;
paramClauses      : paramClause* (NEWLINE? LPAREN 'implicit' params RPAREN)?
  ;
paramClause       : NEWLINE? LPAREN params? RPAREN
  ;
params            : param (',' param)*
  ;
param             : annotation* ID (':' paramType)?
  ;
paramType         :
    type
  | '=>' type
  | type '*'
  ;
classParamClauses :
    classParamClause* (NEWLINE? LPAREN 'implicit' classParams RPAREN)?
  ;
classParamClause  : NEWLINE? LPAREN classParams? RPAREN
  ;
classParams       : classParam ('' classParam)*
  ;
classParam        : annotation* (modifier* ('val' | 'var'))? ID ':' paramType
  ;
bindings          : LPAREN binding (',' binding)* RPAREN
  ;
binding           : (ID | '_') (':' type)?
  ;
modifier          :
    localModifier
  | accessModifier
  | 'override'
  ;
localModifier     :
    'abstract'
  | 'final'
  | 'sealed'
  ;
accessModifier    : ('private' | 'protected') accessQualifier?
  ;
accessQualifier   : LBRACK (ID | 'this') RBRACK
  ;
annotation        : '@' annotationExpr
  ;
annotationExpr    : constr (NEWLINE? LCURLY (nameValuePair (',' nameValuePair)*)? RCURLY)?
  ;
nameValuePair     : 'val' ID '=' prefixExpr
  ;
templateBody      : NEWLINE? LCURLY selfType? templateStat (eoi templateStat)* RCURLY
  ;
templateStat      :
    import0
  | (annotation NEWLINE?)* modifier* def
  | (annotation NEWLINE?)* modifier* dcl
  | expr
  ;
selfType          :
    ID (':' type)? '=>'
  | 'this' ':' type '=>'
  ;
import0            : 'import' importExpr (',' importExpr)*
  ;
importExpr        : stableId '.' (ID | '_' | importSelectors)
  ;
importSelectors   : LCURLY (importSelector ',')* (importSelector | '_') RCURLY
  ;
importSelector    : ID ('=>' ID | '=>' '_')?
  ;
dcl               :
    'val' valDcl
  | 'var' varDcl
  | 'def' funDcl
  | 'type' NEWLINE? typeDcl
  ;
valDcl            : ids ':' type
  ;
varDcl            : ids ':' type
  ;
funDcl            : funSig (':' type)?
  ;
funSig           :  ID funTypeParamClause? paramClauses
  ;
typeDcl          :  ID typeParamClause? ('>:' type)? ('<:' type)?
  ;
patVarDef        :
    'val' patDef
  | 'var' varDef
  ;
def              :
    patVarDef
  | 'def' funDef
  | 'type' NEWLINE? typeDef
  | tmplDef
  ;
patDef           :  pattern2 (',' pattern2)* (':' type)? '=' expr
  ;
varDef           :
    patDef
  |  ids ':' type '=' '_'
  ;
funDef           :
    funSig (':' type)? '=' expr
  |  funSig NEWLINE? LCURLY block RCURLY
  |  'this' paramClause paramClauses ('=' constrExpr | NEWLINE? constrBlock)
  ;
typeDef          :  ID typeParamClause? '=' type
  ;
tmplDef          :
  'case'? 'class' classDef
  |  'case'? 'object' objectDef
  |  'trait' traitDef
  ;
classDef         :  ID typeParamClause? annotation* accessModifier? classParamClauses classTemplateOpt
  ;
traitDef         :  ID typeParamClause? traitTemplateOpt
  ;
objectDef        :  ID classTemplateOpt
  ;
classTemplateOpt :  extends classTemplate | (extends? templateBody)?
  ;
traitTemplateOpt :  extends traitTemplate | (extends? templateBody)?
  ;
extends          :  'extends' | '<:'
  ;
classTemplate    :  earlyDefs? classParents templateBody?
  ;
traitTemplate    :  earlyDefs? traitParents templateBody?
  ;
classParents     :  constr ('with' annotType)*
  ;
traitParents     :  annotType ('with' annotType)*
  ;
constr           :  annotType argumentExprs*
  ;
earlyDefs        : LCURLY (earlyDef (eoi earlyDef)*)? RCURLY 'with'
  ;
earlyDef         :  (annotation NEWLINE?)* modifier? patVarDef
  ;
constrExpr       :
    selfInvocation
  | constrBlock
  ;
constrBlock      :  LCURLY selfInvocation (eoi blockStat)* RCURLY
  ;
selfInvocation   :  'this' argumentExprs argumentExprs*
  ;
topStatSeq        :  topStat (eoi topStat)*
  ;
topStat           :
    (annotation NEWLINE?)? (modifier)? tmplDef
  | import0
  | packaging
  ;
packaging        :  'package' qualId NEWLINE? LCURLY topStatSeq RCURLY
  ;
compilationUnit  :  ('package' qualId eoi)? topStatSeq
  ;

// XML support removed



/////////////////////////////////////////////////////////////////////
//Lexer rules
//lexer grammar python_v3;ASSIGN
//@lexer::options
//{
//	k = 3;
//	testLiterals = true;
//	charVocabulary='\u0003'..'\ufffe';
//	language = Java;
//}

LONG_LITERAL
    :   IntegerNumber LongSuffix
    ;


INT_LITERAL
    :   IntegerNumber
    ;

fragment
IntegerNumber
    :   '0'
    |   '1'..'9' ('0'..'9')*
    |   '0' ('0'..'7')+
    |   HexPrefix HexDigit+
    ;

fragment
HexPrefix
    :   '0x' | '0X'
    ;

fragment
HexDigit
    :   ('0'..'9'|'a'..'f'|'A'..'F')
    ;

fragment
LongSuffix
    :   'l' | 'L'
    ;


fragment
NonIntegerNumber
    :   ('0' .. '9')+ '.' ('0' .. '9')* Exponent?
    |   '.' ( '0' .. '9' )+ Exponent?
    |   ('0' .. '9')+ Exponent
    |   ('0' .. '9')+
    |
        HexPrefix (HexDigit )*
        (    ()
        |    ('.' (HexDigit )* )
        )
        ( 'p' | 'P' )
        ( '+' | '-' )?
        ( '0' .. '9' )+
        ;

fragment
Exponent
    :   ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    ;

fragment
FloatSuffix
    :   'f' | 'F'
    ;

fragment
DoubleSuffix
    :   'd' | 'D'
    ;

FLOAT_LITERAL
    :   NonIntegerNumber FloatSuffix
    ;

DOUBLE_LITERAL
    :   NonIntegerNumber DoubleSuffix?
    ;

CHAR_LITERAL
    :   '\''
        (   EscapeSequence
        |   ~( '\'' | '\\' | '\r' | '\n' )
        )
        '\''
    ;

/** Match various string types.  Note that greedy=false implies '''
 *  should make us exit loop not continue.
 */
STRING_LITERAL
    :   '"'
        (   EscapeSequence
        |   ~( '\\' | '"' | '\r' | '\n' )
        )*
        '"'
  | '"""' (options {greedy=false;}:.)* '"""'
    ;

fragment
EscapeSequence
    :   '\\' (
                 'b'
             |   't'
             |   'n'
             |   'f'
             |   'r'
             |   '\"'
             |   '\''
             |   '\\'
             |
                 ('0'..'3') ('0'..'7') ('0'..'7')
             |
                 ('0'..'7') ('0'..'7')
             |
                 ('0'..'7')
             )
;


BOOLEAN_LITERAL : 'true' | 'false' ;

fragment
UPPER            : 'A'..'Z' | '$' | '_';  //TODO and Unicode category Lu
fragment
LOWER            : 'a'..'z'; //TODO and Unicode category Ll
fragment
LETTER           : UPPER | LOWER; //TODO and Unicode categories Lo, Lt, Nl
fragment
DIGIT            : '0'..'9';
fragment
OPCHAR           : '+'|'-'|'*'|'/'|'='; //'\u0020'..'\u007F'; // TODO and Unicode categories Sm, So except parentheses ([]) and periods
OP               : OPCHAR+;
fragment
IDREST           : (LETTER | DIGIT)* ('_' OP)?;
VARID            : LOWER IDREST;
PLAINID          : UPPER IDREST
                 | VARID
                 | OP
                 ;
ID               : PLAINID
                 | '\'' STRING_LITERAL '\''
                 ;
SYMBOL_LITERAL :	'`' IDREST
  ;

LPAREN	: '(' {implicitLineJoiningLevel++;} ;

RPAREN	: ')' {implicitLineJoiningLevel--;} ;

LBRACK	: '[' {implicitLineJoiningLevel++;} ;

RBRACK	: ']' {implicitLineJoiningLevel--;} ;


SEMI	: ';' ;

//BACKQUOTE	: '`' ;

LCURLY	: '{' {implicitLineJoiningLevel++;} ;

RCURLY	: '}' {implicitLineJoiningLevel--;} ;

/*
DOT : '.' ;

FLOAT  	:	POINTFLOAT | EXPONENTFLOAT
//	:	'.' DIGITS (Exponent)?
//    |   DIGITS ('.' (DIGITS (Exponent)?)? | Exponent)
    ;
POINTFLOAT
  :	DIGITS? FRACTION | DIGITS '.'
  ;
FRACTION
  :	'.' DIGITS
  ;
EXPONENTFLOAT
  :	(DIGITS | POINTFLOAT) Exponent
  ;
LONGINT
    :   INT ('l'|'L')
    ;

fragment
Exponent
  :	('e' | 'E') ( '+' | '-' )? DIGITS
  ;

INT :   // Hex
        '0' ('x' | 'X') ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
        ('l' | 'L')?
    |   // Octal
        '0' DIGITS*
    |   '1'..'9' DIGITS*
    ;

fragment
DIGITS : ( '0' .. '9' )+ ;

NAME:	( 'a' .. 'z' | 'A' .. 'Z' | '_')
        ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
    ;

fragment
ESC
  :	'\\' .
  ;
*/
/** Consume a newline and any whitespace at start of next line */
CONTINUED_LINE
  :	'\\' ('\r')? '\n' (' '|'\t')* {
     //fModule.acceptLine(getColumn());
     /*newline();*/ $channel=HIDDEN; }
  ;

WS	:	{startPos>0}?=> (' '|'\t')+ {$channel=HIDDEN;}
  ;

/** Comments not on line by themselves are turned into newlines because
    sometimes they are newlines like

    b = a # end of line comment

    or

    a = [1, # weird
         2]

    This rule is invoked directly by nextToken when the comment is in
    first column or when comment is on end of nonwhitespace line.

    The problem is that then we have lots of newlines heading to
    the parser.  To fix that, column==1 implies we should kill whole line.

    Consume any newlines following this comment as they are not statement
    terminators.  Don't let NEWLINE token handle them.
 */

DOC
         @init{
            boolean isDoc = false;
        }
    :   '/*'
            {
                if((char)input.LA(1) == '*'){
                    isDoc = true;
                }
            }
        (options {greedy=false;} : . )*
        '*/'
            {
                if(isJavaDoc==true){
                    $channel=HIDDEN;
                }else{
                    skip();
                }
            }
    ;
COMMENT
@init {
    $channel=HIDDEN;
}
    :	{startPos==0}?=> (' '|'\t')* '#' (~'\n')* '\n'+
    |	{startPos>0}?=> '#' (~'\n')* // let NEWLINE handle \n unless char pos==0 for '#'
    ;

//SPECIAL
//{
//    int startCol = getColumn();
//}
//    :  (~'\n')* // let NEWLINE handle \n unless column = 1 for '#'
//        { $setType(Token.SKIP);
//        	fModule.acceptModifier($getText);
//        	}
//        ( {startCol==1}? ('\n' {
//        	fModule.acceptLine(getColumn());newline();
//}
//        )+ )?
//    ;
/** Treat a sequence of blank lines as a single blank line.  If
 *  nested within a (..), {..}, or [..], then ignore newlines.
 *  If the first newline starts in column one, they are to be ignored.
 */
NEWLINE
    :   (('\r')? '\n' )+
        {if ( startPos==0 || implicitLineJoiningLevel>0 )
            $channel=HIDDEN;
        }
    ;
